sealed abstract class CodePoint {
  def boxed: CodePoint.Utf32
  def asInt: Int = boxed.asInt
}

object CodePoint {
  case class Utf8(private val underlying: Array[Byte]) extends CodePoint {
    override def boxed = Util.decodeAt(underlying,0).boxed
    override lazy val toString = UtfString(underlying).toString
  }

  case class Utf16(private val underlying: Array[Char]) extends CodePoint {
    override def boxed = Util.decodeAt(underlying,0).boxed
    override lazy val toString = UtfString(underlying).toString
  }

  case class Utf32(private val underlying: Int) extends CodePoint {
    override def asInt = underlying
    override def boxed = this
    override lazy val toString = UtfString(underlying).toString
  }
}

abstract class UtfString[U] extends Seq[CodePoint.Utf32] {
  def length: Int
  def toUtf32String: Utf32String
  def toUtf16String: Utf16String
  def toUtf8String: Utf8String
  // ...
}
class Utf32String extends UtfString[Int] { /* ... */ }
class Utf16String extends UtfString[Char] { /* ... */ }
class Utf8String extends UtfString[Byte] { /* ... */ }

import net.arya.utf.Implicits._
object Test1 extends Application {
  val singles = "«küßî»"
  val doubles = "“ЌύБЇ”"

  val doubles8: Utf8String = doubles // 14 bytes long
  val foo: String = doubles8.mkString(":")
}


